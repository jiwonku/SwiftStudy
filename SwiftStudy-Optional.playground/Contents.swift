import UIKit

/*
 Optional
 => nil을 사용할 수 있는 타입과 사용할 수 없는 타입을 구분하고, 사용할 수 있는 타입을 가리켜 옵셔널 타입 이라고 부른다.
 => nil : 값이 없음을 의미하는 특수한 값 / 정수형의 0이나 문자열의 ""과는 다른, 말 그대로 순수하게 아무 값도 없다는 것을 의미.
          실제 값으로는 처리할 수 없는, 무엇인가 문제가 발생했을 때 이를 의미하기 위해 사용된다.
 */

let capital = ["kr" : "seoul" , "cn" : "beging" , "jp" : "tokyo"]
capital["ko"] // nil을 리턴함.
capital["kr"] // "seoul" 을 리턴함.


/*
 스위프트에서는 값을 처리하는 과정에 문제가 있을 경우 많은 부분에서 오류를 발생시키는 대신 결과값을 nil로 반환한다.
 하지만 모든 타입이 nil을 반환할 수 있는 것은 아니며 오직 옵셔널 타입만 nil을 반환할 수 있음.
 nil을 반환하려면 해당 값이 옵셔널 타입으로 정의되어 있어야 함
 */


Int("123") // 123이 리턴됨.
let a = Int("heloo") // nil 이 리턴됨.
//var b = nil
//print(a)
 
/*
 위의 Int("heloo") 같은 경우 대부분의 다른 프로그래밍 언어에서는 오류로 처리하거나 예외사항으로 처리함.
 이렇게 되면 프로그램이 강제로 종료되거나 예상치 못한 동작을 일으킬 수 있음.
 하지만 스위프프에서는 언어의 안정성을 위해 실행을 중지시키거나 오류를 발생시키지 않고 억지로 값을 반환하려고 노력함.
 이때 반환하는 값은 정수 0 이나 문자열 "" 이 아닌, 실패를 의미하면서도 오류를 던지는 것이 아닌 값이어야 함.
 이것이 바로 '값이 없음'을 의미하는 nil.
 */


/*
 스위프트의 nil은 objective-c의 nil과는 의미가 다름.
 objective-c에서는 빈 메모리 주소를 가리키는 값
 스위프트에서는 '값이 없음'을 의미함.
 스위프트에서는 뭔가 연산 과정에서 정상적으로 값을 처리하지 못하는 상황이 발생했을 때 제대로 된 결과값 대신 nil을 반환.
 즉 위에서 Int("heloo") 과 같은 연산의 경우 '인자값이 잘못되었으므로 이 변환 처리는 실패입니다. 따라서 아무 값도 반환되지 않습니다.' 라는 의미를 표현하기 위해 nil을 반환.
 */





//var result : Int = nil;

/*
 그런데 스위프트에서 nil의 사용에 제약을 걸어 둠.
 일반 자료형은 nil값을 가질 수 없음 / 문자열이나 정수 등은 일반 자료형이기 때문에 '값이 없음'을 의미하는 nil값을 저장할 수 없음.
 위 대입은 에러가 발생함.
 그리고 이것은 함수에서 값을 반환할 때도 동일함 /
 함수는 반환 타입이 정해져 있기 때문에 항상 그 반환 타입에 맞는 값을 반환해야 하는데, 처리가 실패했을 때 nil을 반환하면 일반 자료형에 nil을 할당할 수 없는 스위프트 특성 때문에 nil을 리턴하면 오류가 발생.
 */




let v = Int("123")
print(v)



/*
 옵셔널 타입 : 옵셔널 타입으로 선언된 자료형은 nil 값을 저장 할 수 있음.
 
 오류가 발생할 가능성이 있는 함수는 반환 타입을 반드시 옵셔널 타입으로 설정해야 함.
 따라서 Int(문자열) 구문의 반환 타입은 옵셔널 타입으로 정의됨.
 
 옵셔널 타입은 별도로 존재하는 자료형이 아님 / 스위프트에서 모든 기본 자료형들은 그에 대응하는 옵셔널 타입이 존재.
 
 옵셔널 타입이 실제로 가질 수 있는 값의 종류는 오직 두 가지.
 nil이 아닌 값 , nil 값
 nil이 아닌 값은 123, "abv" 등의 구체적인 값이 아니라 정말 nil이 아닌 값 그 자체.
 이것은 반환하려는 실제 값이 옵셔널이라는 객체로 둘러 쌓인 상태를 의미.
 
 처리과정에 문제가 있었다면 nil이 반환되고, 문제가 없어 처리가 성공하면 옵셔널 객체로 감싸진 결과값이 반환됨.
 */


/*
 위의 let v = Int("123") 에서 v를 print 해보면 'Optional(123)' 이 출력됨.
 123을 옵셔널 타입으로 감싸서 리턴한 것.
 옵셔널 타입으로 둘러싸는 것을 '옵셔널 래핑' 이라고 함.
 특수한 처리과정으로 옵셔널 타입을 해제하고 실제 값을 추출하는 것을 '옵셔널 언래핑' 이라고 함.
 */



var optInt : Int?

var optStr : String?

var optDouble : Double?

/*
 옵셔널 타입 선언
 사용하는 자료형 뒤에 ? 를 붙이면 됨.
 일반 자료형은 선언만 하고 초기화 하지 않으면 아예 아무것도 할당되지 않지만, 옵셔널 타입으로 자료형을 선언하면 자동으로 nil로 초기화가 됨.
 물론 옵셔널 내부에 있는 자료형에 nil이 부여되는 것이 아니라 옵셔널 타입 자체에 nil이 부여됨.
 */

optInt = 3
optStr = "abc"
optDouble = 3.0

/*
 옵셔널 타입에 값을 대입할 때는 일반 변수처럼 생각하고 다루어도 무방함.
 */




//Int("123") + Int("456") // 옵셔널 타입은 연산을 지원하지 않는 타입 / 해당 구문은 에러가 발생.




/*
 옵셔널 값을 사용하려면 옵셔널 객체를 해제해야 함 : 옵셔널 언래핑(optinal unwrapping)
 
 1. 명시적 해제
    1-1. 강제 해제
    1-2. 비강제 해제
 
 2. 묵시적 해제
    2-1. 컴파일러에 의한 자동 해제
    2-2. ! 연산자를 사용한 자동 해제 
 */


/*
 강제 해제
 */

var optInt2 : Int? = 3

print(optInt2) // Optional(3)
print(optInt2!) // 3


Int("123")! + Int("456")! // 579



/*
 강제 해제 연산자를 사용할 때는 먼저 옵셔널 값이 nil인지 체크해야 함.
 옵셔널 값이 nil이 아닐 때만 강제 해제 연산자를 붙여넣 값을 추출해야 함.
 */


var str = "123"
var intFromStr = Int(str)

if intFromStr != nil {
    print(intFromStr!)
} else {
    print("return value is failed")
}


/*
 위 구문에서 str이 123 이면 123이 출력되고, srt이 'abc'이면 "return value is failed" 가 리턴됨.
 
 Int(문자열) 생성자는 옵셔널 정수값을 반환함.
 따라서 그 결과를 대입받는 intFromStr 상수 역시 옵셔널 타입으로 정의됨.
 옵셔널은 값이 nil인지 아닌지를 if 구문으로 검사해야 하고 그에 맞는 조건절 블럭 내에서만 장제 해제 연산자를 사용해야 함.
 즉, ! 연산자는 확실히 옵셔널 값이 nil이 아닌 조건에서만 사용해야 함.
 
 위 구문에서 intFromStr != nil 에서 intFromStr와 != 사이에 공백이 존재함.
 이는 가독성을 위해서 넣은 것이 아니라 문법의 오류를 방지하기 위한 목적.
 공백을 두지 않으면 컴파일러가 확실하게 해석을 하지 못하여 구문 분석 오류가 발생하게 됨.
 
 */
